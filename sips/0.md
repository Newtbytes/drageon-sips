# Lorax Rewrite Rule Framework

## Introduction

This proposal introduces a rewrite rule mechanism for the SillyDrageon C Compiler. Rewrite rules are designed to match specific patterns in the compiler's input and transform them according to predefined logic. This feature aims to simplify and automate certain transformations within the compiler.

## Motivation

Rewrite rules are highly prevalent in a wide array of applications, most notably in compilers. They are used in translations between IRs, optimizations on IRs, as well as instruction selection and peephole optimization for assembly codegen.

A generalized and flexible abstraction for rewrite rules would enable their use for a wide variety of purposes in SillyDragon.

## Design

Rewrite rules consist of three main components:

1. **`match`**: This represents the left-hand side (LHS) of the rule. It has the following responsibilities:
   - Matches input patterns.
   - Returns an `Option<RuleMatch<T>>` if the match is successful.
   - The `Option<RuleMatch<T>>` contains a newtype wrapper around the matched node.
   - Ensures type safety by allowing a `RuleMatch` to be constructed only through a successful match.

2. **`rewrite`**: This function takes a `RuleMatch<T>` and applies the right-hand side (RHS) transformation. It assumes the input matches the LHS pattern and does not perform additional checks.

3. **`apply`**: This function combines the match and rewrite functions into a single operation. It takes a `T` and returns an `Option<T>`. The `apply` function has a default implementation in the `RewriteRule` trait.

4. **`apply_inplace`**: Similar to `apply`, but it operates on `&mut T` and modifies the input directly without returning a value. While the `apply` is useful for immutably performing a transformation and saving the result for later, `apply_inplace` is useful when a rewrite needs to be performed immediately.

## Implementation Details

- `match`: The `match` function is implemented to ensure that only valid matches are returned. The `RuleMatch` struct has private members and a public struct, ensuring it can only be constructed through a successful match.

- `rewrite`: The `rewrite` function assumes the input matches the LHS pattern. It applies the RHS transformation without additional validation, relying on the correctness of the `match` function.

- `apply`: The `apply` function wraps the `match` and `rewrite` functions. It provides a default implementation in the `RewriteRule` trait, simplifying its usage.

- `apply_inplace`: The `apply_inplace` function modifies its input directly. It is useful for scenarios where in-place transformations are more efficient.

## Prior Art

Similar rewrite rule mechanisms exist in other compilers and frameworks, such as LLVM's pattern-matching infrastructure, ISLE in Cranelift, and MLIR's pattern-matching infrastructure. LLVM's TableGen and MLIR's DRR provide domain-specific languages for defining patterns and transformations, focusing on ease of use and integration with their respective ecosystems. ISLE in Cranelift emphasizes compactness and efficiency for instruction selection. The proposed mechanism in SillyDrageon aims to provide a generalized and flexible abstraction that can be adapted to various use cases, similar to these already existing pattern rewriting and rewrite rule systems. A declarative rewrite rule system utilizing a `rewrite_rule!` macro is also planned.

## Alternatives
